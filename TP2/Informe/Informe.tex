\documentclass[12pt, titlepage, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage{prftree}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem} 
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[spanish]{babel}
\usepackage{amsthm}
\usepackage{bussproofs}
\usepackage{bm}
\usepackage{url}
\usepackage{hyperref}
\usepackage{dirtytalk}

\usepackage{titlesec}
\usepackage[export]{adjustbox}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


\usepackage[a4paper, total={6in, 8in}]{geometry}


\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}


\title{Resumen Inteligencia Artificial}
\author{}

\begin{document}

\section{Introduccion}
La idea de este trabajo es modelar una ontología sobre lenguajes de  
programación, en la cual se relaciones características de estos. La idea 
principal es que permita ayudar a un programador a elegir un lenguaje 
apropiado según sus necesidades. 

\section{Pasos a Seguir}
Para guiarnos en la creacion de la ontologia seguimos el \say{Pipeline} que 
vimos en clase, el cual consiste en lo siguientes pasos:

\subsection{Determinar dominio y alcance}
En esta instancia nos planteamos preguntas que debe poder ser respondidas  
por la ontología. De las preguntas propuestas elegimos: 
\begin{itemize}
    \item {\say{¿Qué lenguajes funcionales tienen tipado estático y fuerte?}} 
\end{itemize}

Ademas planteamos las siguientes preguntas a responder:
%Completar (No me las acuerdo)

\subsection{Analizar Reuso}
Para poder desarrollar mas clases y características utilizamos una ontologia 
ya creada, de esta forma pudimos encontrar:
\begin{itemize}
    \item % Completar con lo sacado del pdf de ontologia
\end{itemize}

\subsection{Enumerar términos}
En base a todo lo anterior comenzamos a enumerar los términos que 
aparecen en la ontología, respondiendo preguntas como.
\begin{itemize}
    \item {¿De qué términos necesitamos hablar?}
    \item {¿Cuáles son las propiedades de esos términos?}
    \item {¿Qué queremos decir acerca de esos términos?}
\end{itemize}
Surgiendo los siguientes conceptos
\begin{itemize}
    \item {lenguajes
            \begin{itemize}
                \item {C}
                \item {Python}
                \item {Haskell}
                \item {Assembler}
            \end{itemize}}
    \item {Forma de ejecución}
    \item {Nivel de abstracción}
    \item {Paradigma}
    \item {Sistema de tipos
            \begin{itemize}
                \item {Chequeo}
                \item {Seguridad}
                \item {Declaración}
            \end{itemize}}
\end{itemize}
y muchos mas que fueron apareciendo en el transcurso de la creación de 
la ontología.

\subsection{Definición de Clases y jerarquía}
Para crear las clases nos basamos en que, una clase es una colección 
de elementos con propiedades similares, quedándonos algo como:

% Completar

% Hacer mencion al tema de las instancias

\subsection{Definición propiedades de las clases (slots)}
Aca es donde pensamos slots, estos describen los atributos de una instancia 
en una clase y la relación con otras instancias. En ejemplo de esto seria, 
\say{Cada \textbf{Lenguaje} tiene su \textbf{Paradigma}} o 
\say{Cada \textbf{Lenguaje} tiene un \textbf{Nivel de abstracción}}

\subsection{Restricción de Propiedades}
Es este sección, se establecieron los posibles valores de los slots esto 
seria:
%Falta completar

\subsection{Crear instancias}
Al final creamos las instancias que mencionamos antes y le asginamos 
valores a los slots creados.

\section{Resultados obtenidos con el razonador}
% Aca mencionamos lo que ocurre al dejar que protege razone y cree mas relaciones

% Iamgen de la ontologia (OWLViz)

\section{Consultas realizadas}
% Hacemos un par de consultas y explicamos el resultado

\section{Conclusion}
%Mecionar
% Si surgieron diferentes posturas en la conceptualización
% Inconvenientes
% Si hay problemas de representacion
\end{document}